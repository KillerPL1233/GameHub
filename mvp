MVP — GameHub — wymagania funkcjonalne i techniczne (wersja minimalna)

Świetnie — poniżej znajdziesz kompletny, praktyczny opis MVP portalu GameHub (serwis tematyczny — katalog gier) zaprojektowany tak, żeby pokryć wymienione cele edukacyjne: od powtórki JS, przez Node/Express i REST API, po frontend Vue.js i dobre praktyki. Zawiera: lista funkcji, user stories, model danych, przykładowe REST-endpointy, algorytm rankingowy, kryteria akceptacji oraz przypisanie funkcji do tematów nauki (1–7).

1. Krótki opis produktu (MVP)

GameHub to prosty portal katalogujący gry (może być dostosowany do książek/filmów/muzyki). Umożliwia:

przeglądanie bazy gier,

tworzenie prywatnych list użytkownika (np. posiadane, ukończone, do ogrania),

ocenianie i komentowanie gier,

automatyczne rankingi (popularność/ocena),

podstawowa administracja (dodawanie/edycja wpisów przez admina).

MVP ma być prosty, ale zaprojektowany tak, by można było stopniowo dopracowywać i rozszerzać.

2. Priorytetowane funkcje MVP (najważniejsze na początku)

Rejestracja / logowanie (email + hasło, JWT)

Strona główna / katalog gier — lista z paginacją, sortowaniem, filtrowaniem (gatunek, platforma, rok)

Kartka gry (detail) — opis, obrazek, gatunki, linki, średnia ocena, liczba ocen, komentarze

Prywatne listy użytkownika — tworzenie nazwanej listy + dodawanie/usuń gier (np. „Posiadane”, „Do ogrania”)

Oceny (1–5) i komentarze — każdy zarejestrowany użytkownik może ocenić i skomentować

Ranking popularności — automatycznie wyliczany na podstawie aktywności

Panel administratora — dodawanie/edycja/usuwanie gier, zarządzanie użytkownikami

REST API – komplet endpointów do powyższych akcji

Frontend w Vue.js – interfejs użytkownika, responsywność

Podstawowe testy i dokumentacja API

3. User stories (MVP) — przykłady i kryteria akceptacji

Jako niezalogowany użytkownik chcę przeglądać listę gier, żeby zobaczyć co jest w serwisie.
AC: widzę stronę listy z tytułem, miniaturą, średnią oceną i gatunkami; mogę filtrować i sortować.

Jako użytkownik zarejestrowany chcę dodać grę do mojej prywatnej listy „Do ogrania”.
AC: gra pojawia się na mojej liście, widzę ją w profilu; inne osoby nie widzą moich prywatnych list.

Jako użytkownik chcę ocenić grę (1–5) i dodać komentarz.
AC: ocena wpływa na średnią; komentarz pojawia się pod grą w czasie rzeczywistym (lub po odświeżeniu).

Jako administrator chcę dodać nową grę do katalogu.
AC: nowa gra jest widoczna w katalogu; wszystkie wymagane pola walidowane.

Jako użytkownik chcę zobaczyć ranking „Top 10 popularnych gier”.
AC: lista aktualizuje się na podstawie aktywności (oceny/komentarze/listy/wyświetlenia).

4. Model danych (proponowana struktura relacyjna / dokumentowa)

Poniżej wersja relacyjna (SQL) — można analogicznie zaprojektować w MongoDB.

users

id (PK), email, password_hash, display_name, role (user/admin), created_at

games

id (PK), title, slug, description, release_year, platforms (json/relacja), genres (json/relacja), cover_url, created_by, created_at

user_lists

id, user_id (FK), name, is_public (bool), created_at

user_list_items

id, list_id (FK), game_id (FK), added_at

ratings

id, user_id, game_id, score (1–5), created_at, updated_at

comments

id, user_id, game_id, body, created_at, edited_at

activity_stats

game_id, views_count, ratings_count, comments_count, lists_count — (można odświeżać batchowo)

tags (opcjonalnie)

id, name

game_tags

game_id, tag_id

5. Przykładowe REST API (kontrakty)

Uwaga: używamy JSON; autentykacja JWT w headerze Authorization: Bearer <token>.

GET /api/games?page=1&perPage=20&genre=RPG&sort=popular
Response: { data: [{id,title,slug,cover_url,avgScore,genres}], meta:{page,...} }

GET /api/games/:id
Response: { id, title, description, platforms, avgScore, ratingsCount, comments: [{...}] }

POST /api/auth/register
Body: { email, password, display_name }

POST /api/auth/login
Body: { email, password }
Response: { token, user:{id,display_name} }

POST /api/games/:id/rate
Body: { score: 4 }
Auth required

POST /api/games/:id/comments
Body: { body: "świetna gra!" }
Auth required

POST /api/user/lists
Body: { name: "Do ogrania", is_public: false }

POST /api/user/lists/:listId/items
Body: { game_id: 123 }
Auth required

GET /api/rankings/popular?limit=10
Response: [{ game_id, title, popularity_score }]


Dobrze dodać też endpointy admina:

POST /api/admin/games
PUT /api/admin/games/:id
DELETE /api/admin/games/:id

6. Prosty algorytm rankingu popularności (przykład)

Obliczamy popularity_score dla każdego game:

popularity_score = 0.4 * normalized_views
                 + 0.3 * normalized_avgRating * log(1 + ratings_count)
                 + 0.15 * normalized_comments_count
                 + 0.15 * normalized_lists_count


Normalizacja: każde pole skalujemy do [0,1] względem max/min w zestawie lub z użyciem znormalizowanego percentyla (bardziej odporne na outliery).

Można agregować i odświeżać score periodycznie (cron) lub przy zmianach (event-driven).

7. Mapowanie wymagań edukacyjnych (1–7) na funkcje i zadania implementacyjne

JavaScript: powtórzenie podstaw i zaawansowane techniki

Zadania: moduły ES6+, asynchroniczność (fetch/async-await), obsługa błędów, testy jednostkowe funkcji pomocniczych, wzorce (factory, module).

Gdzie: kod frontend (Vue) i proste skrypty backendowe.

Node.js i Express — budowa backendu

Zadania: struktura projektu, middleware (auth, error handling, logging), routing, walidacja (Joi/express-validator), testy integracyjne.

Gdzie: serwer API, autoryzacja JWT, obsługa plików (upload okładek).

Bazy danych i REST API

Zadania: projekt schematu, CRUD, paginacja, indeksy, transakcje (jeśli potrzebne), przygotowanie migracji (Knex/Sequelize/Migrations), dokumentacja API (OpenAPI/Swagger).

Gdzie: endpoints CRUD dla gier, list, ocen.

4–5. Frontend: Vue.js

Zadania: komponenty (GameCard, GameDetail, UserLists, RatingComponent), stan aplikacji (Pinia/Vuex), routowanie (vue-router), formularze, lazy loading, responsywność.

Gdzie: cały UI, integracja z REST API.

Web API

Zadania: integracja z zewnętrznym API (np. pull meta danych o grach z IGDB/RAWG — opcjonalne), zabezpieczanie i ograniczanie zapytań (rate limit), CORS, dokumentacja OpenAPI.

Gdzie: import danych, autouzupełnianie (autocomplete).

Zaawansowane zagadnienia i dobre praktyki

Zadania: CI/CD (lint, testy), monitoring (Sentry), logowanie, testy e2e (Cypress), zabezpieczenia (OWASP: XSS, SQLi, CSRF), optymalizacja (cache, CDN), use of environment variables.

Gdzie: cały projekt.

8. Niefunkcjonalne wymagania (warto uwzględnić w MVP)

Bezpieczeństwo: hash hasła bcrypt/argon2, JWT + refresh tokens, rate limiting.

Wydajność: paginacja, indeksy DB, cache dla rankingów.

Dostępność: podstawowe ARIA, responsywność.

Skalowalność: oddzielenie API od frontendu, łatwa migracja DB.

Testy: unit, integracyjne, smoke tests.

9. Minimalny backlog / kamienie milowe (bez estymacji czasowych — tylko kolejność prac)

Milestone A — Podstawy backendu & DB

Projekt DB, podstawowy Express server, auth (register/login), CRUD gier (admin).

Milestone B — REST API i logika aplikacji

Endpoints: listy użytkownika, ratingi, komentarze, activity stats.

Milestone C — Frontend minimalny (Vue)

Katalog gier, game detail, auth (login/register), user lists, rating/comment UI.

Milestone D — Rankingi, admin, dokumentacja

Implementacja algorytmu popularności, panel admina, OpenAPI.

Milestone E — Dobre praktyki

Testy, CI pipeline, podstawowe audyty bezpieczeństwa, monitoring.

10. Przykładowy przepływ implementacji (technologie i biblioteki)

Backend: Node.js, Express, Sequelize/TypeORM/Knex (SQL) lub Mongoose (MongoDB), JWT, bcrypt, express-validator, winston/morgan

DB: PostgreSQL (zalecane) lub MongoDB

Frontend: Vue 3, Pinia (state), vue-router, Vite, Composition API

DevOps: Docker, GitHub Actions / GitLab CI, Nginx, Cloud provider (Heroku/Vercel/Render/AWS)

Testy: Jest (backend), vitest/Jest (frontend), Cypress (e2e)

Dokumentacja: OpenAPI/Swagger

11. Przykładowe fragmenty kodu / komponenty (schematycznie)

Endpoint oceny (Express)

// POST /api/games/:id/rate
router.post('/games/:id/rate', authMiddleware, async (req, res) => {
  const { id } = req.params;
  const { score } = req.body; // 1..5
  // walidacja, zapis/aktualizacja ratingu, odświeżenie stats
  res.json({ success: true, avgScore: newAvg, ratingsCount: newCount });
});


Vue — komponent Rating (schemat)

<template>
  <div class="rating">
    <button v-for="n in 5" :key="n" @click="rate(n)">{{ n }}</button>
    <div>Średnia: {{ avg }}</div>
  </div>
</template>
<script setup>
import { ref } from 'vue';
const props = defineProps({ gameId: Number, avg: Number });
const rate = async (n) => {
  await fetch(`/api/games/${props.gameId}/rate`, { method:'POST', body:JSON.stringify({score:n}) });
  // odświeżenie stanu
}
</script>

12. Kryteria „gotowości” MVP

Zarejestrowany użytkownik może: ocenić grę, dodać komentarz, stworzyć listę i dodać do niej grę.

Niezalogowany użytkownik może przeglądać katalog i kartę gry.

Administrator może dodać/edytować gry.

Ranking „Top 10” generuje się i wyświetla.

Podstawowe testy uruchamiają się i przechodzą.

13. Dodatkowe pomysły na rozszerzenia (po MVP)

Integracja z zewnętrznym API (okładki, metadane).

System rekomendacji („podobne gry”).

Social: follow, feed, powiadomienia.

Integracja OAuth (Google, Discord).

Media upload (zrzuty ekranu), galerie.

Jeśli chcesz, mogę od razu:

wygenerować szczegółowe OpenAPI (swagger) dla opisanych endpointów,

wypisać konkretny schema SQL (CREATE TABLE) dla zaproponowanej bazy,

przygotować szkielet projektu (drzewo plików + minimalne pliki startowe dla Express + Vue),

albo zrobić mapowanie zadań do lekcji/ćwiczeń dla kursu (co realizuje który temat 1–7) — wybierz którą z tych opcji przygotować i zrobię to od razu.
